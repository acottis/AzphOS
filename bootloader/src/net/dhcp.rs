//! this will deal with everything DHCP
//! 
const DHCP_OPTIONS_LEN: usize = 157; // Max allowed size
pub const DHCP_TOTAL_LEN: usize = DHCP_OPTIONS_LEN + 240; // 240 is the size before options

const MAGIC: u32 = 0x63825363;
const OPTIONS: [u8; DHCP_OPTIONS_LEN] = [
    0x35,0x01,0x01,0x39,0x02,0x05,0xc0,0x5d,0x02,0x00,0x00,0x5e,0x03,0x01,0x02,0x01
    ,0x3c,0x20,0x50,0x58,0x45,0x43,0x6c,0x69,0x65,0x6e,0x74,0x3a,0x41,0x72,0x63,0x68
    ,0x3a,0x30,0x30,0x30,0x30,0x30,0x3a,0x55,0x4e,0x44,0x49,0x3a,0x30,0x30,0x32,0x30
    ,0x30,0x31,0x4d,0x04,0x69,0x50,0x58,0x45,0x37,0x17,0x01,0x03,0x06,0x07,0x0c,0x0f
    ,0x11,0x1a,0x2b,0x3c,0x42,0x43,0x77,0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0xaf
    ,0xcb,0xaf,0x2d,0xb1,0x05,0x01,0x80,0x86,0x10,0x0e,0xeb,0x03,0x01,0x14,0x01,0x17
    ,0x01,0x01,0x22,0x01,0x01,0x13,0x01,0x01,0x11,0x01,0x01,0x27,0x01,0x01,0x19,0x01
    ,0x01,0x10,0x01,0x02,0x21,0x01,0x01,0x15,0x01,0x01,0x18,0x01,0x01,0x12,0x01,0x01
    ,0x3d,0x07,0x01,0x52,0x54,0x00,0x12,0x34,0x56,0x61,0x11,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff
];

use super::Serialise;

use super::{
    nic::NetworkCard, 
    packet::{Packet, EtherType, IPv4, Udp, Protocol}, 
    MAC
};

pub fn init(nic: &NetworkCard){

    let dhcp = DHCP::new();
    let udp = Udp::new(dhcp.serialise());
    let ipv4 = IPv4::new(Protocol::UDP(udp));

    let packet = Packet::new(EtherType::IPv4(ipv4));

    nic.send(packet);

}

#[repr(C)]
pub struct DHCP{
    op: u8,
    htype: u8,
    hlen: u8,
    hops: u8,
    xid: u32,
    secs: u16,
    flags: u16,
    ciaddr: u32,
    yiaddr: u32,
    siaddr: u32,
    giaddr: u32,
    chaddr: [u8; 6],
    _chaddr_padding: [u8; 10],
    _bootp_padding: [u8; 192],
    magic: u32,
    options: [u8; DHCP_OPTIONS_LEN]
}

impl DHCP {
    fn new() -> Self {
        Self {
            op: 0x1,
            htype: 0x1,
            hlen: 0x6,
            hops: 0,
            xid: (0x13371337 as u32).to_be(),
            secs: (4u16).to_be(),
            flags: 0,
            ciaddr: 0,
            yiaddr: 0,
            siaddr: 0,
            giaddr: 0,
            chaddr: MAC,
            _chaddr_padding: [0u8; 10],
            _bootp_padding: [0u8; 192],
            magic: MAGIC.to_be(),
            options: OPTIONS,
        }
    }
}

impl Serialise for DHCP{
    fn serialise(&self) -> &[u8] 
    where Self: Sized{
    unsafe {
        &*core::ptr::slice_from_raw_parts((&*self as *const Self) as *const u8, DHCP_TOTAL_LEN)
    }
}
}
